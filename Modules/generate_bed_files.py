import os
import csv
import glob
import subprocess
import numpy as np
import pandas as pd

def get_targets_from_dataframe(df, min_jump=1e6, overhang=500):
    """
    to generate a bed file, we need to know the exon ranges of interest
    function reads in a dataframe, and for each chromosome, gets the start and end ranges
    min_jump specifies the number of basepairs 2 exons on a chromosome need to be separated by,
    so that they count as coming from different regions
    overhang is added to the start and end position to overhanging reads
    """
    
    assert type(min_jump) in (int, float)
    assert type(overhang) is int
    assert type(df) is pd.core.frame.DataFrame
    
    # initialize value
    targets = []
    
    # evaluate by chromosome
    for chromosome in set(df.Chromosome):
        df_chrome = df.loc[df.Chromosome == chromosome].copy()
        
        # get distances between exons
        df_chrome['Dist'] = 0
        start_vals = df_chrome.Start.iloc[1:].values
        end_vals = df_chrome.End.iloc[:-1].values
        col_ind = df_chrome.columns.tolist().index('Dist')
        df_chrome.iloc[1:,col_ind] = start_vals - end_vals
        
        # use positions where Dist >= min_jump to split the dataframe
        dividers = np.arange(df_chrome.shape[0],dtype=int)[df_chrome['Dist'] >= min_jump]
        dividers = dividers.tolist()
        dividers.insert(0,0)
        dividers.append(df_chrome.shape[0])
        
        # for each region, add target info to targets
        for start, end in zip(dividers[:-1], dividers[1:]):
            df_sub = df_chrome.iloc[start:end]
            region_start = df_sub.Start.min() - overhang
            region_end = df_sub.End.max() + overhang
            targets.append('%s:%d-%d' % (chromosome, region_start, region_end))
            
    return ' '.join(targets)

def get_bams(dataset='Lab_Pvalb'):
    """
    get list of existing bam files
    """
    
    if dataset in ('Lab_Pvalb', 'Lab_OLM', 'Tasic_Hb', 'Gouwens_Hb'):
        bams = glob.glob('/media/soma/Storage1/LabCounts/%s/*.bam' % dataset)
    else:
        bams = glob.glob('/media/soma/Storage1/datasets/%s/*.bam' % dataset)
    bams = {bam.split('/')[-1].split('.ba')[0]:bam for bam in bams}
    return bams

def get_commands(targets, dirname, overwrite=False, dataset='Lab_Pvalb'):
    """
    get list of commands for creating the appropriate bed files
    save them as a bash file
    if overwrite is False, in cases where a bed file already exists, skip that bam file
    """
    
    # get list of bam files
    bams = get_bams(dataset=dataset)
    
    # make sure target directory exists
    outdir = '/media/soma/Storage1/BedFiles/%s_full' % dirname
    if not os.path.isdir(outdir):
        subprocess.Popen(['mkdir', outdir], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
    
    # generate commands by bam file
    commands = []
    for bam, bamloc in bams.items():
        write_file = '%s/%s.bam' % (outdir, bam)
        bed_file = '%s/%s.bed' % (outdir, bam)
        
        # check file existence
        if os.path.isfile(bed_file) and not overwrite:
            continue

        read_command = 'samtools view -b %s %s > %s' % (bamloc, targets, write_file)
        write_command = 'bedtools bamtobed -bed12 -i %s > %s' % (write_file, bed_file)
        remove_command = 'rm %s' % write_file

        commands += [read_command, write_command, remove_command, '']
    
    # save commands
    with open('Commands/generate_beds.sh', 'w') as w:
        w.write('#!/bin/sh\n\n')
        w.write('\n'.join(commands))
        
    return

def organize_beds(dirname, overwrite=False):
    """
    bed files generated by bedtools are somewhat unwieldy
    this function reorganizes them into an easier to work with format
    """
    
    cwd = os.getcwd()
    
    # make sure target directory exists
    outdir = '/media/soma/Storage1/BedFiles/%s' % dirname
    if not os.path.isdir(outdir):
        subprocess.Popen(['mkdir', outdir], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
        
    # get list of existing bed files and initialize variables
    beds = glob.glob('/media/soma/Storage1/BedFiles/%s_full/*.bed' % dirname)
    beds.sort()
    base_text = '{chro}\t{strand}\t{start}\t{end}\t{size}\n'
    temp_file = 'Commands/temp.bed'
    
    # iterate by bed file
    for bed_file in beds:
        bed_out = bed_file.replace('%s_full' % dirname, dirname)
        if os.path.isfile(bed_out) and not overwrite:
            continue
        
        # write initially to temp_file
        with open(temp_file, 'w') as w:
            with open(bed_file) as f:
                reader = csv.reader(f, delimiter='\t')
                
                for data in reader:
                    chrome = data[0]
                    start = int(data[1])
                    end = int(data[2])
                    strand = data[5]
                    block_sizes = data[10]
                    block_starts = data[11]
                    
                    block_sizes = [int(size) for size in block_sizes.split(',')]
                    block_starts = [int(b_start) for b_start in block_starts.split(',')]
                    length = sum(block_sizes)
                    
                    for b_size, b_start in zip(block_sizes, block_starts):
                        e_start = start + int(b_start)
                        e_end = e_start + int(b_size)
                        w.write(base_text.format(chro=chrome, start=e_start, end=e_end, size=length, strand=strand))
        
        # sort temp_file and save results to bed_out
        command_sort = ['sort', '-k1,1', '-k2,2', '-k3n', temp_file]
        
        with open(bed_out, 'w+') as f:
            subprocess.Popen(command_sort, cwd=cwd, stderr=subprocess.PIPE, stdout=f).communicate()
    
    return

def generate_data(targets, dirname, overwrite=False, dataset='Lab_Pvalb'):
    """
    function to generate bed file data to work with
    targets is a string of chromosome locations to write to
    dirname is name of directory we want to save stuff to
    overwrite is in case we already used the target directory before, and determines whether to overwrite preexisting files
    """
    
    get_commands(targets, dirname, overwrite=overwrite, dataset=dataset)
    subprocess.Popen(['bash', 'Commands/generate_beds.sh'], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
    organize_beds(dirname, overwrite=overwrite)
    
    return